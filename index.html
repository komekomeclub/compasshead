<div id="map"></div>

<div id="ui-layer">
    <div id="version-label" class="ui-element">[ver9]</div>
    <div id="debug-info" class="ui-element">Angle: ---</div>
    <div id="crosshair"></div> <button id="compass-btn" class="ui-element round-btn">ğŸ§­</button>
    <button id="rotate-btn" class="ui-element round-btn">ğŸ”„</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
    const DECLINATION_CORRECTION = -7;

    // åœ°å›³åˆæœŸåŒ–
    const map = L.map('map', { zoomControl: false }).setView([35.681236, 139.767125], 16);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let currentLat = null;
    let currentLng = null;
    let currentMarker = null;
    let directionLine = null;
    
    let isCompassActive = false;
    let isMapRotating = false;
    let lastHeading = 0;

    const compassBtn = document.getElementById('compass-btn');
    const rotateBtn = document.getElementById('rotate-btn');
    const debugInfo = document.getElementById('debug-info');
    const mapDiv = document.getElementById('map');

    function onLocationFound(e) {
        currentLat = e.coords.latitude;
        currentLng = e.coords.longitude;
        
        if (!currentMarker) {
            currentMarker = L.circleMarker([currentLat, currentLng], {
                color: 'blue', fillColor: '#30f', fillOpacity: 0.5, radius: 10
            }).addTo(map);
            map.setView([currentLat, currentLng], 16);
        } else {
            currentMarker.setLatLng([currentLat, currentLng]);
        }

        if (isMapRotating) {
            map.setView([currentLat, currentLng], map.getZoom(), { animate: false });
        }

        if (isCompassActive) drawCompassLine(lastHeading);
    }

    if (navigator.geolocation) {
        navigator.geolocation.watchPosition(onLocationFound, null, { enableHighAccuracy: true });
    }
    
    map.on('move', () => {
        if (isCompassActive && currentLat) drawCompassLine(lastHeading);
    });

    compassBtn.addEventListener('click', async () => {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response !== 'granted') return;
            } catch (e) {}
        }

        isCompassActive = !isCompassActive;
        
        if (isCompassActive) {
            compassBtn.classList.add('active');
            startSensor();
        } else {
            compassBtn.classList.remove('active');
            if (isMapRotating) toggleRotateMode();
            stopSensor();
            if (directionLine) {
                map.removeLayer(directionLine);
                directionLine = null;
            }
        }
    });

    rotateBtn.addEventListener('click', () => {
        if (!isCompassActive) {
            alert("å…ˆã«å·¦ã®ã‚³ãƒ³ãƒ‘ã‚¹ãƒœã‚¿ãƒ³(ğŸ§­)ã‚’ONã«ã—ã¦ãã ã•ã„");
            return;
        }
        toggleRotateMode();
    });

    function toggleRotateMode() {
        isMapRotating = !isMapRotating;
        
        if (isMapRotating) {
            rotateBtn.classList.add('active');
            if(currentLat) map.setView([currentLat, currentLng], map.getZoom());
            rotateBtn.innerText = "â¬†ï¸";
        } else {
            rotateBtn.classList.remove('active');
            // marginã§é…ç½®ã—ã¦ã„ã‚‹ã®ã§ã€æˆ»ã™ã¨ãã¯ rotate(0deg) ã ã‘ã§OK
            mapDiv.style.transform = `rotate(0deg)`;
            rotateBtn.innerText = "ğŸ”„";
        }
    }

    function startSensor() {
        if ('ondeviceorientationabsolute' in window) {
            window.addEventListener('deviceorientationabsolute', handleOrientation);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
        }
    }

    function stopSensor() {
        if ('ondeviceorientationabsolute' in window) {
            window.removeEventListener('deviceorientationabsolute', handleOrientation);
        } else {
            window.removeEventListener('deviceorientation', handleOrientation);
        }
        debugInfo.innerText = "Angle: ---";
    }

    function handleOrientation(event) {
        let heading = 0;
        if (event.webkitCompassHeading) {
            heading = event.webkitCompassHeading;
        } else if (event.absolute === true || event.alpha !== null) {
            heading = 360 - event.alpha;
        }

        heading += DECLINATION_CORRECTION;
        if (heading < 0) heading += 360;
        if (heading >= 360) heading -= 360;

        lastHeading = heading;
        debugInfo.innerText = `Angle: ${Math.round(heading)}Â°`;
        
        drawCompassLine(heading);

        if (isMapRotating) {
            // marginã§ä¸­å¿ƒã«ã‚ã‚‹ã®ã§ã€å˜ç´”ã« rotate ã ã‘ã§å›ã‚‹ï¼ˆtranslateä¸è¦ï¼‰
            mapDiv.style.transform = `rotate(-${heading}deg)`;
        }
    }

    function drawCompassLine(heading) {
        if (currentLat === null || currentLng === null) return;
        
        const centerLatLng = map.getCenter();
        const cornerLatLng = map.getBounds().getNorthEast();
        const distMeters = map.distance(centerLatLng, cornerLatLng);
        const lengthKm = (distMeters * 1.2) / 1000;

        const headingRad = heading * (Math.PI / 180);
        const dy = (lengthKm / 111) * Math.cos(headingRad);
        const dx = (lengthKm / (111 * Math.cos(currentLat * Math.PI / 180))) * Math.sin(headingRad);

        const latlngs = [
            [currentLat, currentLng],
            [currentLat + dy, currentLng + dx]
        ];

        if (directionLine) map.removeLayer(directionLine);

        directionLine = L.polyline(latlngs, {
            color: 'orange', weight: 5, opacity: 0.7
        }).addTo(map);
    }
</script>
